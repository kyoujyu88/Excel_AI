Option Explicit

' =========================================================
'  Excel AI チャットクライアント (交換日記方式)
' =========================================================

' 設定：AIの返事を待つ最大時間（秒）
' ※混み合っている可能性もあるので、少し長めの120秒にしています
Const TIMEOUT_SECONDS As Integer = 120

' ---------------------------------------------------------
' メイン処理：送信ボタンに登録するマクロ
' ---------------------------------------------------------
Sub AskAI()
    Dim ws As Worksheet
    ' ※シート名は実際のExcelに合わせて変更してください（例: "Sheet1"）
    Set ws = ActiveSheet 
    
    ' 1. 質問の取得
    Dim question As String
    question = ws.Range("B3").Value
    
    If Trim(question) = "" Then
        MsgBox "質問文が入力されていません。だんごも悲しみます...", vbExclamation
        Exit Sub
    End If
    
    ' ----------------------------------------------------
    ' ★重要設定：郵便ポスト（共有フォルダ）の場所
    ' ----------------------------------------------------
    Dim boxPath As String
    
    ' ▼ テスト用：このExcelと同じ場所にある "exchange_box" フォルダを使う
    boxPath = ThisWorkbook.Path & "\exchange_box\"
    
    ' ▼ 本番運用用：ファイルサーバーなどを使う場合は、以下のように書き換えてください
    ' boxPath = "\\192.168.1.10\Public\Excel_AI\exchange_box\"
    
    ' フォルダ確認
    If Dir(boxPath, vbDirectory) = "" Then
        MsgBox "共有フォルダが見つかりません。" & vbCrLf & "場所: " & boxPath, vbCritical
        Exit Sub
    End If
    
    ' 2. ユニークIDの生成（PC名 + 日時 + ランダム数字）
    ' これで、他の人とファイル名が被るのを防ぎます
    Dim myID As String
    Randomize ' 乱数の初期化
    myID = Environ("COMPUTERNAME") & "_" & Format(Now, "yyyymmddhhmmss") & "_" & Int((999 - 100 + 1) * Rnd + 100)
    
    ' ファイル名の決定
    Dim reqFile As String, resFile As String
    reqFile = boxPath & "req_" & myID & ".txt"  ' 私が出す手紙
    resFile = boxPath & "res_" & myID & ".txt"  ' 私宛の返事
    
    ' 3. 質問を書き込む（UTF-8で保存）
    Call WriteTextUTF8(reqFile, question)
    
    ' 画面を「考え中」モードにする
    Application.Cursor = xlWait
    ws.Range("B6").Value = "（だんご大家族が相談中です... そのままお待ちください...）"
    DoEvents ' 画面描画を更新
    
    ' 4. 回答を待つループ（ポーリング）
    Dim startTime As Single
    startTime = Timer
    
    Dim response As String
    response = ""
    Dim isTimeout As Boolean
    isTimeout = False
    
    Do
        DoEvents ' Excelが固まらないように息継ぎ
        
        ' (A) タイムアウト判定
        If Timer - startTime > TIMEOUT_SECONDS Then
            isTimeout = True
            Exit Do
        End If
        
        ' (B) 自分宛ての返事ファイルがあるか確認
        If Dir(resFile) <> "" Then
            
            ' ★安全装置：ファイルサイズが0より大きいか確認
            ' Pythonがファイルを作った瞬間に読み込んでしまうのを防ぎます
            If FileLen(resFile) > 0 Then
                
                ' 念のため、書き込み完了を確実にするため一瞬待つ
                Application.Wait (Now + TimeValue("0:00:01"))
                
                ' 中身を読み込む
                response = ReadTextUTF8(resFile)
                
                ' もし万が一読み込めなかった場合のリトライ処理
                If Len(response) > 0 Then
                    ' 読み終わったファイルは削除（お片付け）
                    On Error Resume Next
                    Kill resFile
                    On Error GoTo 0
                    
                    Exit Do ' ループを抜ける（完了！）
                End If
            End If
            ' ※サイズが0だった場合は、見なかったことにしてループを継続します
        End If
        
        ' 0.5秒待機（連打してサーバーに負荷をかけないため）
        Application.Wait (Now + TimeValue("0:00:01") / 2)
    Loop
    
    ' 5. 結果表示と後始末
    Application.Cursor = xlDefault ' カーソルを戻す
    
    If isTimeout Then
        ws.Range("B6").Value = "エラー：応答がありませんでした。（タイムアウト）" & vbCrLf & "サーバーが止まっているか、混み合っている可能性があります。"
        ' 残ってしまったリクエストファイルを消しておく
        On Error Resume Next
        Kill reqFile
        On Error GoTo 0
    Else
        ws.Range("B6").Value = response
    End If
    
End Sub

' ---------------------------------------------------------
' 関数1：テキストをUTF-8（BOMなし）で書き込む
' ※PythonはUTF-8が好きなので、この形式で渡してあげます
' ---------------------------------------------------------
Sub WriteTextUTF8(filePath As String, textContent As String)
    Dim stream As Object
    Set stream = CreateObject("ADODB.Stream")
    
    With stream
        .Type = 2 ' adTypeText (テキストモード)
        .Charset = "UTF-8"
        .Open
        .WriteText textContent
        
        ' BOM（先頭につくゴミコード）を削除する魔法
        .Position = 0
        .Type = 1 ' adTypeBinary (バイナリモードに変更)
        .Position = 3 ' BOMの3バイト分をスキップ
        
        Dim binaryData As Variant
        binaryData = .Read ' BOM以降のデータだけ吸い出す
        
        .Close ' 一旦閉じる
        .Open  ' また開く
        .Write binaryData ' 綺麗なデータを書き込む
        .SaveToFile filePath, 2 ' 上書き保存
        .Close
    End With
End Sub

' ---------------------------------------------------------
' 関数2：テキストをUTF-8で読み込む
' ※AIからの返事はUTF-8で来るので、文字化けしないように読みます
' ---------------------------------------------------------
Function ReadTextUTF8(filePath As String) As String
    Dim stream As Object
    Dim text As String
    Set stream = CreateObject("ADODB.Stream")
    
    ' 読み込み時に競合エラーが出ないようにエラー無視を設定
    On Error Resume Next
    
    With stream
        .Type = 2 ' adTypeText
        .Charset = "UTF-8"
        .Open
        .LoadFromFile filePath
        text = .ReadText
        .Close
    End With
    
    If Err.Number <> 0 Then
        ' エラー時は空文字を返してリトライさせる
        text = "" 
    End If
    On Error GoTo 0
    
    ReadTextUTF8 = text
End Function
